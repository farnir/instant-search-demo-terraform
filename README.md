# Prerequisites

## Kubernetes Cluster
We will need a Kubernetes cluster to deploy our application located at:
[Link to project](https://github.com/farnir/instant-search-demo)

In this example we will use [MiniKube](https://github.com/kubernetes/minikube) because it's easy to use and really fast to setup.

To install minikube you can follow the documentation [here](https://minikube.sigs.k8s.io/docs/start/).

But for Linux on a x86-64 architecture the commands will be:
```bash
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube
```

Minikube can use many different drivers to run but the most common is Docker.

You can found how to install Docker Desktop or Docker Engine [here](https://docs.docker.com/desktop/linux/install/ubuntu/).


Then we need to start our cluster with minikube with the command:
```bash
minikube start
```

## Kubectl
We will also need Kubectl in order to control our Kubernetes cluster.

You can install kubectl from [there](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/#install-kubectl-binary-with-curl-on-linux).
For example with curl on linux, it will be:
```bash
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
```

## Terraform
We will need the tool Terraform that will help us create the basic configuration of our cluster.

In this project we used Terraform v1.2.2, you can find it [here](https://www.terraform.io/downloads).

Terraform providers will use the kubernetes configuration commonly found in "~/.kube/config" by default, if it's not your case you may need to change the file [maint.tf](https://github.com/farnir/instant-search-demo-terraform/blob/main/terraform/main.tf).

# How to setup
Now that all our tools have been installed, we just need to setup our cluster with Terraform.
```bash
cd terraform
terraform init
terraform apply
```

When the terraform is done, the setup is already over.
We now have our application running on 2 pods on the cluster. 

If the master branch is updated and tagged correctly, a new image will be build and then deploy on our cluster thanks to ArgoCD.
The tag syntax accepted is semver compliant: vX.X.X-env.

**Congratulation!** 

> ðŸ’¡ By default the image tagged **v1.0.2-dev** will be deployed. It contains exactly the same file found in the algolia/instant-search-demo.

> ðŸš€ If ArgoCD has been deployed correctly, the latest image in the Github Archives registry will be deployed which is **v1.0.3-dev** but it may take a moment (2 to 3 minutes). To recognize the latest version, the Search bar placeholder text has been changed for: **Search for products by fish, boat, wave, ...**.


#### Access Instant Search Demo
You may have difficulties to access the Cluster IP / NodePort services generated by the Kubernetes cluster.

The issue may come from Docker in Windows, where the network is limited and this Node IP is not reachable directly.

In order to solve that you can create tunnel to the NodeIP directly with minikube with the command:
```bash
minikube service {name_of_your_service} --url -n {namespace}
ps -ef | grep docker@127.0.0.1
```
Here name_of_your_service is **instant-search-service** and namespace is **algolia-dev**.

You can access your application web page with the result of ps command that will precise the port.

Link will be **127.0.0.1:{port_found}**

#### Access ArgoCD WebUI
In this cluster you will find ArgoCD that is handling the image deployment and the registry scan.
To access the WebUI you can setup a ssh tunnel:
```bash
kubectl port-forward svc/argocd-server -n argocd 8080:443
```
Also you can find the non encrypted password here, default user is *admin*:
```bash
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d; echo
```